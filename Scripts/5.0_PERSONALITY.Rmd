---
title: "Personality"
author: "Hamza"
date: "12/02/2020"
output:
  html_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---


### Load packages
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#checks for installation and loads packages
pacman::p_load(lmerTest,ggThemeAssist,rptR,lme4,readxl, tidyr, dplyr, magrittr, lubridate, stringr, purrr,
               sjPlot,ggplot2,lubridate,wesanderson,ggbeeswarm,emmeans,patchwork,viridis,nlme,Rmisc,ggpubr,
               stargazer, brms, MCMCglmm)

```

### Converting from wide to long data format   
```{r}
Personality <- read.csv("./Data/Personality/ALL.csv")
Post_assay <- read.csv("./Data/Personality/Post-assay.csv")

# making a column with a factor where the four levels correspond to the four phases
Personality$phase <-  factor(Personality$Time, levels = c("6-9", "13-16", "20-23", "27-30")) 

# making a list where each level of the list is a different phase
phases <- split(Personality, Personality$phase)

# function to apply to the four phases: 1, 2, 3, and 4
func_phase <- function(phase = 1){
    df <- phases[[phase]] # getting phase dataframe based on index (1-4)
    df$Behaviour <- df[,paste0("Phase",phase)] # getting columns that says which behaviour was in that phase
    df <- df[,!(names(df) %in% paste0("Phase", 1:4))] # removing the now-redundant Phase1,...,Phase4 columns
    return(df) # return dataframe
}

# applying function, returning a list of four dataframes
Personality_list <- lapply(1:4, function(x) func_phase(x))
Personality_df <- bind_rows(Personality_list) # stakes dataframe on top of each other

# making an ID for the tank info (four phases in a session)
Personality_df <- Personality_df %>% mutate(fish_session_ID = paste(Fish_ID, Date, Session, Camera)) %>% arrange(fish_session_ID) 

# turning from wide to long
vars <- c("tot_dist", "mean_speed", "mean_dist_05",  
          "tot_dist_05", "freeze_dur", "zone_510_dur",  
          "zone_05_dur",  "zone_2025_dur","zone_1520_dur", 
          "zone_3035_dur", "zone_1015_dur", "zone_3540_dur", 
          "zone_2530_dur", "zone_near_dur", "zone_middle_dur", 
          "zone_far_dur",  "arena_dur",  "moving_dur")
info <- c("Time", "Day", "Date",  "Arena",   "Sex", "Mark", "Session", "Camera",  "Group",  "Fish_ID", "Notes")

# four behaviours
behavs <- c("Aggression", "Novel", "Predator", "Social")

# function to rename variables for each behaviour
func_variable_behav <- function(behav = behavs[1]){
    behav_vars <- Personality_df[Personality_df$Behaviour == behav,vars] # getting just the variables for that behaviour
    names(behav_vars) <- paste(names(behav_vars), behav, sep = "_") # renaming variables so they say which behaviour they relate to
    return(behav_vars)
}
# applying function to each behaviour
vars_behavs_list <- lapply(behavs, function(x) func_variable_behav(x))
# putting the four behaviour columns next to each other
vars_behavs <- bind_cols(vars_behavs_list) 

# adding info
Personality_wide <- cbind(Personality_df[Personality_df$Behaviour == "Aggression", info], vars_behavs)


### Adding in activity data (post-assay) to Personality_wide

Personality_wide <- left_join(Post_assay, Personality_wide)

# five behaviours
behavs <- c("Aggression", "Novel", "Predator", "Social", "Activity") #modified to include activity so we can run functions below
```

### Residual distributions and repeatability values for each variable    
Using Shapiro-Wilk normality test   
See ?shapiro.test
More normal = higher W value and smaller p value
```{r}
func_behav_raw <- function(behav = behavs[1]){
  
  func_var <- function(var = vars[1]){
    mod <- lmer(Personality_wide[,paste(var,behav,sep="_")] ~ Group*Sex + (1 | Fish_ID), data = Personality_wide) 
    residuals <- resid(mod)
    VC <- data.frame(VarCorr(mod))
    rpt <- round(VC$vcov[1]/sum(VC$vcov),2)
    sw <- shapiro.test(residuals)
    df <- data.frame(behav, var, rpt, W = round(sw$statistic,3), p = round(sw$p.value,3))
    return(df)
  } # raw general linear model to determine whether transformations are required
  

  
 rpt_vals <- bind_rows(lapply(vars, function(x) func_var(x)))
 return(rpt_vals)
}

func_behav_sqrt <- function(behav = behavs[1]){
  
  func_var <- function(var = vars[1]){
    mod <- lmer(sqrt(Personality_wide[,paste(var,behav,sep="_")]) ~ Group*Sex + (1 | Fish_ID), data = Personality_wide) # added a square root transformation here to the model
    residuals <- resid(mod)
    VC <- data.frame(VarCorr(mod))
    rpt <- round(VC$vcov[1]/sum(VC$vcov),2)
    sw <- shapiro.test(residuals)
    df <- data.frame(behav, var, rpt, W = round(sw$statistic,3), p = round(sw$p.value,3))
    return(df)
  } # same general linear model as above but with a square root transformation
  

  
 rpt_vals <- bind_rows(lapply(vars, function(x) func_var(x)))
 return(rpt_vals)
}

# RUNNING MODELS 

rpt_resids <- bind_rows(lapply(behavs, function(x) func_behav_raw(x))) # not transformed

rpt_resids_sqrt <- bind_rows(lapply(behavs, function(x) func_behav_sqrt(x))) # sqrt transformed

# CHECKING TO SEE WHICH VARIABLES ARE NORMAL AND WHICH REQUIRE TRANSFORMATION

# restricting to just values of W > 0.9 and seeing which variables are represented for all behaviors

rpt_resids %>% filter(W>0.9) %>% group_by(var) %>% tally()


# only mean_speed and tot_dist are there for everything


filter(rpt_resids, var == "mean_speed") # all looks good, except p-val for Aggression?

filter(rpt_resids, var == "tot_dist") # similar to above?

# zone_near_dur there for 4/5, so we want to check which phase would need to be transformed 

filter(rpt_resids, var == "zone_near_dur") 

#this shows that the "Social" phase needs a transformation for the variable zone_near_dur, so we'll see if a square root transformation helps

rpt_resids_sqrt %>% filter(W>0.9) %>% group_by(var) %>% tally()

filter(rpt_resids_sqrt, var == "zone_near_dur")

# The square root transformation doesn't help for the variable zone_near_dur for the Social phase, so will try to identify another variable that can be used for all 5 phases as long as transformations work

rpt_resids %>% filter(W>0.9) %>% group_by(var) %>% tally()

#Will try to see tot_dist_05
 
filter(rpt_resids, var == "tot_dist_05")

#Social and Aggression require transformations, will see if the sqrt transformations helped

filter(rpt_resids_sqrt, var == "tot_dist_05")

#Aggression phase is good with a square root transformation, Social phase improved, possibility it can be used?

# Will now check zone_05_dur

filter(rpt_resids, var == "zone_05_dur")

#Not too fussed with Activity phase as we will use a distance variable, however, Novel phase needs to be transformed. Will see if the transformation helps with normality

filter(rpt_resids_sqrt, var == "zone_05_dur")

#A square root transformation appears to have done the job.

# To summarize, we can use the following variables for analysis

# Mean speed (all 5 phases), total distance (all 5 phases), zone_05_dur (Novel phases requires a square root transformation)
```


### Run lmer models for chosen behaviour   
```{r}
# Chosen variables: total distance for activity, zone_05_dur for stimulus phases

# ROSE: you could modify the function so you can do it all at once:
func_mod_behav_vars  <- function(var,df = Personality_wide){
  mod <- lmer(df[,var] ~ Group*Sex + (1 | Fish_ID), data = df)
  if(str_detect(var, "Novel")){ # if the variable = Novel, we will square-root the variable
    mod <- lmer(sqrt(df[,var]) ~ Group*Sex + (1 | Fish_ID), data = df) 
  }

  return(mod) 
  
}

behav_vars <- c("zone_05_dur_Social", "zone_05_dur_Predator", "zone_05_dur_Novel", "zone_05_dur_Aggression", "tot_dist_Activity") # including novel and changing activity from zone_05_dur to tot_dist_Activity
mod_list_5behav <- lapply(behav_vars, function(x) func_mod_behav_vars(x)) 
names(mod_list_5behav) <- behav_vars

lmer_zone_05_dur_Social <- lmer(zone_05_dur_Social ~ Group*Sex + (1 | Fish_ID), data = Personality_wide) #Extra model to check

fixef(lmer_zone_05_dur_Social) == fixef(mod_list_5behav$zone_05_dur_Social) # they're the same

#lmer_zone_05_dur_Novel <- lmer(sqrt(zone_05_dur_Novel) ~ Group*Sex + (1 | Fish_ID), data = Personality_wide) # Extra model to check

```


### Extract BLUPs from lmer models and plot fitted versus. predicted      
- make a dataframe with the model parameters    
- fitted = the actual measured behaviors
- predicted = the model predictions, calculated according to the below equation:

$$y_{ij} = \beta_0 + \text{ID}_j + \beta_1(\text{treatment})+ \beta_2(\text{male}) + \beta_3(\text{treatment}\cdot\text{male}) + e_i$$ 
$$\text{ID} \sim \text{N}(0,\sigma^2_{\text{ID}})$$
$$e \sim \text{N}(0,\sigma^2_{\text{e}})$$

```{r}

func_fitted_predicted <- function(variable = behav_vars[1]){ 
  mod <- mod_list_5behav[[variable]] # using the variable name to get the model
  #getting population parameters
  betas <- fixef(mod)
b0 <- betas[1]
b1 <- betas[2]
b2 <- betas[3]
b3 <- betas[4]
# getting blups
blups <- data.frame(ranef(mod))
round(mean(blups$condval)) # average of blups = 0
# finding the treatment and male value for each fish_ID
fish_ID <- as.character(blups$grp)
# need to match fish_ID ID with their info
pos <- match(fish_ID, Personality_wide$Fish_ID)
mod_pars <- data.frame(fish_ID, b0, ID = blups$condval, b1, b2, b3, treatment = ifelse(Personality_wide$Group[pos] == "Treatment",1,0), male = ifelse(Personality_wide$Sex[pos]=="male",1,0)) %>% mutate(predicted = b0 + ID + b1*treatment + b2*male + b3*(treatment*male))
(Personality_wide$Fish_ID[pos] == fish_ID) # all TRUE
# finding predicted values
pos <- match(Personality_wide$Fish_ID, mod_pars$fish_ID)
(mod_pars$fish_ID[pos]==Personality_wide$Fish_ID) # all TRUE
fitted_predicted <- mod_pars[pos,] 
fitted_predicted$fitted<- Personality_wide[,variable]
fitted_predicted$variable_name <- variable
return(fitted_predicted) 
}

# applying this function to our variables
fitted_predicted_list <- lapply(behav_vars, function(x) func_fitted_predicted(variable = x))

# Function to plot fitted vs. predicted and calculate R2
func_fitted_predicted_plots <- function(df =
                                          fitted_predicted_list[[2]]){
  behav<- gsub(".*dur\\_|.*dist\\_", "", df$variable_name[1]) 
  
  R2<- cor(df$fitted, df$predicted)^2 %>% round(3)
  
  plot<- ggplot(df)+
    theme_classic()+
    geom_point(aes(x=fitted, y=predicted))+
    labs(x=df$variable_name[1],
         title=behav,subtitle=paste0("R2 = ", R2))
  
  return(plot)
}

plot_list_behavs <- lapply(fitted_predicted_list, function(x) func_fitted_predicted_plots(x))

plot_list_behavs[[1]]
plot_list_behavs[[2]]
plot_list_behavs[[3]]
plot_list_behavs[[4]]
plot_list_behavs[[5]]

```


### Repeat the above steps in brm (which uses stan), and compare the results to the lmer models   
```{r}
#Here To-do:

# - Write a function that will input your brm model object, and output two things: (1) the posterior distributions of population paramaters; (2) the fitted and predicted values for posterior means.
behav_vars <- c("zone_05_dur_Social", "zone_05_dur_Predator", "zone_05_dur_Novel", "zone_05_dur_Aggression", "tot_dist_Activity") 


load("./Models/mod_list_brms.Rdata")

options(mc.scores = parallel::detectCores())


func_brm_mod <- function(var, df = Personality_wide){
  df$response <- df[,var] # formula argument relies entirely on the data argument, so you can't just call the columns directly

  if(str_detect(var, "Novel")){ 
    brm <- brm(formula = sqrt(response) ~ Group*Sex + (1 | Fish_ID), 
                                  data = df,
                                  family = gaussian(),
                                  chains = 3,
                                 iter = 2000, warmup = 1000)
  }else{ # ROSE TIP: before, for novel, you had to run two models. Now, you only run one (one of the other). Because baysian models take a while to run, this will speed up the function.
      brm <- brm(formula = response ~ Group*Sex + (1 | Fish_ID), 
                                  data = df,
                                  family = gaussian(),
                                  chains = 3,
                                 iter = 2000, warmup = 1000)
  }

  return(brm)
}


# mod_list_brms <- lapply(behav_vars, function(x) func_brm_mod(x))
# names(mod_list_brms) <- behav_vars
# save(mod_list_brms, file = "./Models/mod_list_brms.Rdata")

# Rose's tips:

func_process_mod <- function(variable = behav_vars[1]){
    mod <- mod_list_brms[[variable]]
    
  mod_posterior <- as.data.frame(mod)
  pop_posterior <- select(mod_posterior,!contains(c("r_Fish_ID", "lp"))) #We don't want to get rid of the variance component ! Hence why "r_Fish_ID" and not "Fish_ID"
  
  b0 <- pop_posterior[,"b_Intercept"] 
  b1 <- pop_posterior[, "b_GroupTreatment"]
  b2 <- pop_posterior[, "b_Sexmale"]
  b3 <- pop_posterior[, "b_GroupTreatment.Sexmale"]
  sigma <- pop_posterior[, "sigma"]
  var_comp <- pop_posterior[, "sd_Fish_ID__Intercept"] 
  
  
  # next, get the posterior means, as you did above
   post_means <- apply(mod_posterior, 2, function(x) mean(x)) # except we don't round because we're using these in subsequent calculations
  
  # to make fitted_predicted, the logic is as follows:
   
   # we have:
   fitted <- Personality_wide[,c("Fish_ID", "Sex", "Group", variable)]
   names(fitted)[names(fitted)==variable] <- "fitted"
   
   
   
   # and we need to get what the model predicted. So you need to solve the model equation from line 219, predicted = B0 + individual_difference + B1*treatment + B2*male + B3*treatment*male.
   
   # to do this calculation, make three more columns from 'fitted': a column of 1s and 0s for treatment,a column of 1s and 0s for male, and a column of individual_difference, which you will get by matching the Fish_ID in each row to the mean BLUP from post_means

   # ROSE:
   blups <- post_means[str_detect(names(post_means), "r_Fish_ID")] # here are your individual differences
   # now use gsub to rename them so the name is just the fish_ID
   names(blups) # see how these are all in the format r_Fish_ID[aXXXX,Intercept]? You need to get them to all be aXXXX, then you can match them up with the fish_IDs in the fitted dataframe.
   
names(blups) <- gsub(".*Fish_ID.", "",  names(blups))
names(blups) <- gsub(".Intercept.", "", names(blups))
# I did this in two steps because I'm not sure how to keep the middle of the string without ruining the entire thing :/ 
names(blups) # Double checking to make sure we have renamed correctly

 fish_ID <- as.character(names(blups)) #converting to characters as we did above
  
  pos <- match(fish_ID, fitted$Fish_ID)
  mod_pars <- data.frame(fish_ID, b0, ID = blups, b1, b2, b3, treatment = ifelse(fitted$Group[pos] == "Treatment",1,0), male = ifelse(fitted$Sex[pos]=="male",1,0)) %>% mutate(predicted = b0 + ID + b1*treatment + b2*male + b3*(treatment*male)) #HAMZA: Issue with matching, we have 3000 values vs. 165 fish ID's ? I suspect I am doing something wrong to match
(Personality_wide$Fish_ID[pos] == fish_ID) 
  
fitted_predicted <- 
   
  return(list(pop_posterior, fitted_predicted))
  
}

```





